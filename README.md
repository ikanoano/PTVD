# PTVD
Very simple path traversal vulnerability detector for java source code.

## Dependency
* JDK 9
* gradle

## How to run
```
$ ./run [target.java] ...
```

## Algorithm

### Overview
入力されたソースコード中の関数定義を調べ、FileI/Oを行う関数で
パスの正規化とサニタイズをする関数が同時に使われているかを確認する。

大まかには、コード中に出現する全ての関数に

* FileI/Oを行う関数(IO)
* パスの正規化を行う関数(NORMALIZED)
* パスのサニタイズを行う関数(SANITIZED)

この3つの属性の組み合わせを付与する。

属性の付与が完了した時点で各関数の属性を調べ、
"FileI/Oが行われているが、正規化とサニタイズの片方でも行われていない"関数が存在する場合、
入力されたコードには脆弱性があると判定する。

### Detail

1. 関数名と関数の属性を保持するテーブルTとUを、空に初期化する。
2. 事前に定義された、FileI/Oを行う関数の関数名と属性(IO)を、Tに追加する。
3. 事前に定義された、パスの正規化を行う関数の関数名と属性(NORMALIZED)を、Tに追加する。
4. 事前に定義された、パスのサニタイズを行う関数の関数名と属性(SANITIZED)を、Tに追加する。
5. 5.1-5.2の処理を3回繰り返す
  5.1. 入力された全てのjavaソースコードに対して、5.1.1-5.1.3を1回ずつ実行する。
    5.1.1. javaソースコードをパースし、ASTを得る。
    5.1.2. ASTをトラバースし、関数_呼び出し_を見つける度に5.1.3を実行する。
    5.1.3. 見つけた関数(callee)の属性(T[callee])を、それを呼んだ関数(caller)の属性(U[caller])に追加する。ただし、T[callee]やU[callee]が存在しない場合は何も属性を持たないものとし、また、IO属性については2で追加されたcalleeでなければ無視する。
  5.2. TをUで上書きする。
6. Tの各要素について、"NORMALIZED属性かSANITIZED属性を持たないかつIO属性を持つ"関数があれば"vulnelable"、そうでなければ"safe"を関数名と共に出力する

### Note

* 関数名が同一でさえあれば同じ関数とみなす。
* FileI/Oを単にラップするような関数、つまりパスの正規化やサニタイズをしないことが通常である関数は、Detailの2で与えたFileI/Oを行う関数のリストの中に含まれているものとする。
* Detailの5を3回繰り返すことによって、NORMALIZED属性とSANITIZED属性は最初にそれが付与された関数の2代親の関数まで遡って付与される。これによってネストされた関数内で行われている正規化やサニタイズに対応している。

## ToDo

FileI/Oを行う関数の引数に文字列リテラルが含まれる場合、
ユーザの入力が介在しない安全なFileI/Oとして脆弱性判定から外す。

## License
MIT

